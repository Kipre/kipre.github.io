<!doctype html>
<html>
  <head>
    <title>WebGL Particle System</title>
    <script src="https://webglfundamentals.org/webgl/resources/m4.js"></script>
    <script type="text/x-vertex-shader" id="particle-update-vert">
      #version 300 es
      precision mediump float;

      uniform float t;
      uniform float dt;
      uniform sampler2D u_RgNoise;

      const float min_speed = 0.005;
      const float max_speed = 0.01;
      const float speed_damping = 1.0 - 0.0001;
      const float alpha_damping = 1.0 - 0.05;
      const float gravity = 0.0001;
      const float slide_duration = 0.3;

      in vec2 i_Position;
      in vec4 i_Color;
      in vec2 i_Velocity;

      out vec2 v_Position;
      out vec4 v_Color;
      out vec2 v_Velocity;

      void main() {
        if (i_Velocity.x == 0.0 && v_Velocity.y == 0.0) {
          if (i_Position.x >= t / slide_duration - 0.5) {
            v_Color = i_Color;
            v_Position = i_Position;
          } else {
            ivec2 noise_coord = ivec2(gl_VertexID % 512, gl_VertexID / 512);
            vec2 rand = texelFetch(u_RgNoise, noise_coord, 0).rg;
            float theta = rand.r * 2.0 * 3.14;
            float x = cos(theta);
            float y = sin(theta);
            v_Velocity =
              vec2(x, y) * (min_speed + rand.g * (max_speed - min_speed));
            v_Position = i_Position;
            v_Color = i_Color;
          }
          return;
        }
        
        v_Position = i_Position + i_Velocity;
        v_Color = vec4(i_Color.xyz, i_Color.w * alpha_damping);
        v_Velocity = i_Velocity * speed_damping + vec2(0, gravity);

      }
    </script>
    <script type="text/x-fragment-shader" id="passthru-frag-shader">
      #version 300 es
      precision mediump float;
      in vec2 v_Position;
      void main() { discard; }
    </script>
    <script type="text/x-vertex-shader" id="particle-render-vert">
      #version 300 es
      precision mediump float;

      in vec2 i_Position;
      in vec4 i_Color;

      out vec4 v_Color;

      void main() {
        gl_PointSize = 1.0;
        gl_Position = vec4(i_Position, 0.0, 1.0);
        v_Color = i_Color;
      }
    </script>
    <script type="text/x-fragment-shader" id="particle-render-frag">
      #version 300 es
      precision mediump float;

      in vec4 v_Color;

      out vec4 o_FragColor;

      void main() {
        o_FragColor = v_Color;
      }
    </script>
  </head>
  <script>
    function createShader(gl, shader_info) {
      const shader = gl.createShader(shader_info.type);
      let i = 0;
      let shader_source = document.getElementById(shader_info.name).text;
      /* skip whitespace to avoid glsl compiler complaining about #version not being on the first line*/
      while (/\s/.test(shader_source[i])) i++;

      shader_source = shader_source.slice(i);
      gl.shaderSource(shader, shader_source);
      gl.compileShader(shader);
      const compile_status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
      if (!compile_status) {
        const error_message = gl.getShaderInfoLog(shader);
        throw (
          'Could not compile shader "' +
          shader_info.name +
          '" \n' +
          error_message
        );
      }
      return shader;
    }

    function createGLProgram(gl, shader_list, transform_feedback_varyings) {
      const program = gl.createProgram();
      for (let i = 0; i < shader_list.length; i++) {
        const shader_info = shader_list[i];
        const shader = createShader(gl, shader_info);
        gl.attachShader(program, shader);
      }

      /* Specify varyings that we want to be captured in the transform
         feedback buffer. */
      if (transform_feedback_varyings != null) {
        gl.transformFeedbackVaryings(
          program,
          transform_feedback_varyings,
          gl.INTERLEAVED_ATTRIBS,
        );
      }
      gl.linkProgram(program);
      const link_status = gl.getProgramParameter(program, gl.LINK_STATUS);
      if (!link_status) {
        const error_message = gl.getProgramInfoLog(program);
        console.log(shader_list);
        throw "Could not link program.\n" + error_message;
      }
      return program;
    }

    function randomRGData(size_x, size_y) {
      const d = [];
      for (let i = 0; i < size_x * size_y; ++i) {
        d.push(Math.random() * 255.0);
        d.push(Math.random() * 255.0);
      }
      return new Uint8Array(d);
    }

    function initialParticleData(imageData, width, height, canvasWidth, canvasHeight) {
      const data = [];
      const dx = canvasWidth / width / 2; 
      const dy = canvasHeight / height / 2; 
      const xpx = 2 / canvasWidth;
      const ypx = 2 / canvasHeight;

      for (let j = 0; j < height; ++j) {
        for (let i = 0; i < width; ++i) {
          const place = (j * width + i) * 4;
          data.push(0.3 - i * xpx);
          data.push(0.3 - j * ypx);
          data.push(imageData[place] / 255);
          data.push(imageData[place + 1] / 255);
          data.push(imageData[place + 2] / 255);
          data.push(imageData[place + 3] / 255);
          data.push(0);
          data.push(0);
        }
      }
      return data;
    }

    // float bytes
    const type_size = 4;

    function setupParticleBufferVAO(gl, buffers, vao) {
      gl.bindVertexArray(vao);
      for (let i = 0; i < buffers.length; i++) {
        const buffer = buffers[i];
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer.buffer_object);
        let offset = 0;
        for (const attrib_name in buffer.attribs) {
          if (buffer.attribs.hasOwnProperty(attrib_name)) {
            const attrib_desc = buffer.attribs[attrib_name];
            gl.enableVertexAttribArray(attrib_desc.location);
            gl.vertexAttribPointer(
              attrib_desc.location,
              attrib_desc.num_components,
              attrib_desc.type,
              false,
              buffer.stride,
              offset,
            );
            offset += attrib_desc.num_components * type_size;
            if (attrib_desc.hasOwnProperty("divisor")) {
              gl.vertexAttribDivisor(attrib_desc.location, attrib_desc.divisor);
            }
          }
        }
      }
      gl.bindVertexArray(null);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }

    function init(gl, imageBuffer, width, height) {
      const num_particles = width * height;

      const update_program = createGLProgram(
        gl,
        [
          { name: "particle-update-vert", type: gl.VERTEX_SHADER },
          { name: "passthru-frag-shader", type: gl.FRAGMENT_SHADER },
        ],
        ["v_Position", "v_Color", "v_Velocity"],
      );
      const render_program = createGLProgram(
        gl,
        [
          { name: "particle-render-vert", type: gl.VERTEX_SHADER },
          { name: "particle-render-frag", type: gl.FRAGMENT_SHADER },
        ],
        null,
      );
      const update_attrib_locations = {
        i_Position: {
          location: gl.getAttribLocation(update_program, "i_Position"),
          num_components: 2,
          type: gl.FLOAT,
        },
        i_Color: {
          location: gl.getAttribLocation(update_program, "i_Color"),
          num_components: 4,
          type: gl.FLOAT,
        },
        i_Velocity: {
          location: gl.getAttribLocation(update_program, "i_Velocity"),
          num_components: 2,
          type: gl.FLOAT,
        },
      };
      const render_attrib_locations = {
        i_Position: {
          location: gl.getAttribLocation(render_program, "i_Position"),
          num_components: 2,
          type: gl.FLOAT,
        },
        i_Color: {
          location: gl.getAttribLocation(render_program, "i_Color"),
          num_components: 4,
          type: gl.FLOAT,
        },
      };
      const vaos = [gl.createVertexArray()];
      const buffers = [gl.createBuffer(), gl.createBuffer()];
      const nbFloats = 8;
      const vao_desc = [
        {
          vao: vaos[0],
          buffers: [
            {
              buffer_object: buffers[0],
              stride: type_size * nbFloats,
              attribs: update_attrib_locations,
            },
          ],
        },
        {
          vao: vaos[1],
          buffers: [
            {
              buffer_object: buffers[1],
              stride: type_size * nbFloats,
              attribs: update_attrib_locations,
            },
          ],
        },
        {
          vao: vaos[2],
          buffers: [
            {
              buffer_object: buffers[0],
              stride: type_size * nbFloats,
              attribs: render_attrib_locations,
            },
          ],
        },
        {
          vao: vaos[3],
          buffers: [
            {
              buffer_object: buffers[1],
              stride: type_size * nbFloats,
              attribs: render_attrib_locations,
            },
          ],
        },
      ];
      const initial_data = new Float32Array(
        initialParticleData(imageBuffer, width, height, canvas.width, canvas.height),
      );
      gl.bindBuffer(gl.ARRAY_BUFFER, buffers[0]);
      gl.bufferData(gl.ARRAY_BUFFER, initial_data, gl.STREAM_DRAW);
      gl.bindBuffer(gl.ARRAY_BUFFER, buffers[1]);
      gl.bufferData(gl.ARRAY_BUFFER, initial_data, gl.STREAM_DRAW);
      for (let i = 0; i < vao_desc.length; i++) {
        setupParticleBufferVAO(gl, vao_desc[i].buffers, vao_desc[i].vao);
      }

      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      const rg_noise_texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, rg_noise_texture);
      gl.texImage2D(
        gl.TEXTURE_2D,
        0,
        gl.RG8,
        512,
        512,
        0,
        gl.RG,
        gl.UNSIGNED_BYTE,
        randomRGData(512, 512),
      );
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      return {
        particle_sys_buffers: buffers,
        particle_sys_vaos: vaos,
        read: 0,
        write: 1,
        particle_update_program: update_program,
        particle_render_program: render_program,
        num_particles: initial_data.length / nbFloats,
        old_timestamp: 0.0,
        rg_noise: rg_noise_texture,
        total_time: 0.0,
      };
    }

    function easeInOutQuad(x) {
      return x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2;
    }

    function render(gl, state, timestamp_millis) {
      const num_part = state.num_particles;

      let time_delta = 0.0;
      if (state.old_timestamp != 0) {
        time_delta = timestamp_millis - state.old_timestamp;
        if (time_delta > 500.0) {
          time_delta = 0.0;
        }
      }

      state.total_time += time_delta;
      state.old_timestamp = timestamp_millis;

      const t = Math.min(1, state.total_time / 1000.0);
      const dt = time_delta / 1000.0;

      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.useProgram(state.particle_update_program);
      gl.uniform1f(
        gl.getUniformLocation(state.particle_update_program, "t"),
        t,
      );
      gl.uniform1f(
        gl.getUniformLocation(state.particle_update_program, "dt"),
        dt,
      );
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, state.rg_noise);
      gl.uniform1i(
        gl.getUniformLocation(state.particle_update_program, "u_RgNoise"),
        0,
      );
      gl.bindVertexArray(state.particle_sys_vaos[state.read]);
      gl.bindBufferBase(
        gl.TRANSFORM_FEEDBACK_BUFFER,
        0,
        state.particle_sys_buffers[state.write],
      );
      gl.enable(gl.RASTERIZER_DISCARD);
      gl.beginTransformFeedback(gl.POINTS);
      gl.drawArrays(gl.POINTS, 0, num_part);
      gl.endTransformFeedback();
      gl.disable(gl.RASTERIZER_DISCARD);
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);

      gl.bindVertexArray(state.particle_sys_vaos[state.read + 2]);
      gl.useProgram(state.particle_render_program);
      gl.drawArrays(gl.POINTS, 0, num_part);

      const tmp = state.read;
      state.read = state.write;
      state.write = tmp;
      window.requestAnimationFrame((ts) => render(gl, state, ts));
    }

    function main() {
      const canvas_element = document.getElementById("canvas");

      const img = new Image();
      img.crossOrigin = "anonymous";
      img.src =
        // "https://20779781.fs1.hubspotusercontent-na1.net/hubfs/20779781/Imported_Blog_Media/Ntombi.jpg";
        "https://media.istockphoto.com/id/1026205392/fr/photo/ext%C3%A9rieur-de-maison-de-luxe-belle-au-cr%C3%A9puscule.jpg?s=612x612&w=0&k=20&c=PAbQWBBSIvWDuLP5lEaZbQ0c41w9BPF2l5AQmNxBuTc=";

      let imageData;

      img.onload = () => {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        canvas.width = img.width;
        canvas.height = img.height;
        context.drawImage(img, 0, 0);
        imageData = context.getImageData(0, 0, img.width, img.height);

        document.body.appendChild(canvas_element);
        canvas_element.width = 800;
        canvas_element.height = 600;
        const webgl_context = canvas_element.getContext("webgl2");
        const state = init(
          webgl_context,
          imageData.data,
          img.width,
          img.height,
        );

        window.requestAnimationFrame((ts) => render(webgl_context, state, ts));
      };
    }
  </script>
  <body onload="main()" style="text-align: center">
    <canvas id="canvas" />
  </body>
</html>
